use crate::parsing_cocci::smpl_grammar::*;

grammar;

// type SpatchType = (&'input str, Vec<usize>);

pub SPatch: Vec<RuleType<'input>> = {
    Rule => vec![<>],
    <mut s:SPatch> <r:Rule> => {s.push(r); s}
}

Ident = {
    r"[a-zA-Z_][(a-zA-Z0-9_)*]"
}

Rule: RuleType<'input> = {
    "@" <r:RuleName> "@" <h:Header> "@@" <d:Disj> => (r, h, d)
}

RuleName: &'input str = {
    // TODO: Add depends
    Ident
}

Header = {
    "" => vec![],
    MetavarDecls
}

MetavarDecls: Vec<Metavar<'input>> = {
    <t:MetavarType> <def:MetavarDef> ";" => vec![make_metavar(t, def)],
    <decls:MetavarDecls> <mty:MetavarType> <def:MetavarDef> ";" => add_metavar(decls, mty, def)
}

MetavarType = {
    "expression",
    "identifier",
    "parameter"
}

MetavarDef: Vec<&'input str> = {
    Ident => vec![<>],
    <mut defs:MetavarDef> "," <ident:Ident> => { defs.push(ident); defs }
}

DisjBranches: DisjElems = {
    <d1: Disj> "|" <d2:Disj> => vec![d1, d2],
    <mut d:DisjBranches> "|" <m:Disj> => {d.push(m); d}
}

OnlyDisj: Vec<DisjElems> = {
    "" => vec![],
    Disj => vec![<>],
    <mut od:OnlyDisj> <d: Disj> => {
        od.push(d);
        od
    }
}

MOrDisj: Vec<DisjElems> = {
    OnlyDisj => <>,//not done
    <m:Mod> <mut od:OnlyDisj> => {od.insert(0, m); od} 
}

Disj: Vec<DisjElems> = {
    "" => vec![DisjElems((String::new(), vec![]))],
    Disj1 => vec![DisjElems::DisjBranches(<>)],
    <m:Mods> <d1:Disj1> <t:Disj> => { let tmp = vec![DisjElems::Mod(m), d1]; tmp.extend(t); tmp },
    <mut t:Disj> <d1:Disj1> <m:Mods> => { t.push(d1); t.push(DisjElems::Mod(m); t )},
    <mut t1:Disj> <d1:Disj1> <m:Mods> <d2:Disj1> <t2:Disj> => {
        t1.push(d1);
        t1.push(DisjElems::Mod(m));
        t1.push(d2);
        t1.extend(t2);
        t1
    }
} 

Disj: Vec<DisjElems> = {
    "" => vec![DisjElems((String::new(), vec![]))],
    Disj1 => vec![DisjElems::DisjBranches(<>)],
    <m:Mods> <d1:Disj1> <t:Disj> => { let tmp = vec![DisjElems::Mod(m), d1]; tmp.extend(t); tmp },
    <mut t:Disj> <d1:Disj1> <m:Mods> => { t.push(d1); t.push(DisjElems::Mod(m); t )},
    <mut t1:Disj> <d1:Disj1> <m:Mods> <d2:Disj1> <t2:Disj> => {
        t1.push(d1);
        t1.push(DisjElems::Mod(m));
        t1.push(d2);
        t1.extend(t2);
        t1
    }
} 

Mods: ModType = {
    r"[a-zA-Z_][(a-zA-Z0-9_)*]" => (<>.to_string(), vec![]),
    <pre:r"[a-zA-Z_][(a-zA-Z0-9_)*]"> "..." <mut post:Mods> => {
        post.0.insert_str(0, pre);
        post.1.insert(0, 0);
        post.1.iter_mut().for_each(|x| *x = *x + pre.len());
        post
    },
}