use crate::parsing_cocci::smpl_grammar::*;

grammar;

// type SpatchType = (&'input str, Vec<usize>);

pub SPatch: Vec<RuleType<'input>> = {
    Rule => vec![<>],
    <mut s:SPatch> <r:Rule> => {s.push(r); s}
}

Ident = {
    r"[a-zA-Z_][(a-zA-Z0-9_)*]"
}

Rule: RuleType<'input> = {
    "@" <r:RuleName> "@" <h:Header> "@@" <d:CM> => (r, h, d)
}

RuleName: &'input str = {
    // TODO: Add depends
    Ident
}

Header = {
    "" => vec![],
    MetavarDecls
}

MetavarDecls: Vec<Metavar<'input>> = {
    <t:MetavarType> <def:MetavarDef> ";" => vec![make_metavar(t, def)],
    <decls:MetavarDecls> <mty:MetavarType> <def:MetavarDef> ";" => add_metavar(decls, mty, def)
}

MetavarType = {
    "expression",
    "identifier",
    "parameter"
}

MetavarDef: Vec<&'input str> = {
    Ident => vec![<>],
    <mut defs:MetavarDef> "," <ident:Ident> => { defs.push(ident); defs }
}

DisjBranches: Vec<DisjElems> = {
    <d1: CM> "|" <d2:CM> => vec![DisjElems::DisjBranches(d1), DisjElems::DisjBranches(d2)],
    <mut d:DisjBranches> "|" <m:CM> => {d.push(DisjElems::DisjBranches(m)); d}
}

Disji: DisjElems = {
    "(" <db:DisjBranches> ")" => DisjElems::DisjBranches(db)
}

OnlyDisjs: Vec<DisjElems> = {

    Disji => vec![<>],
    <mut od:OnlyDisjs> <d: Disji> => {
        od.push(d);
        od
    }
}

MOrDisj: Vec<DisjElems> = {
    //OnlyDisjs => <>,//not done
    //"" => vec![],
    <m:Mods> <mut od:OnlyDisjs> => {od.insert(0, DisjElems::Mod(m)); od} 
}

CM: Vec<DisjElems> = {
    "" => vec![DisjElems::Mod((String::new(), vec![]))],
    OnlyDisjs,
    <mut d:CM> <m:MOrDisj> => {d.extend(m); d},
    <mut d:CM> <mod_: Mods> => {d.push(DisjElems::Mod(mod_)); d}
} 

Mods: ModType = {
    r"[a-zA-Z_][(a-zA-Z0-9_)*]" => (<>.to_string(), vec![]),
    <pre:r"[a-zA-Z_][(a-zA-Z0-9_)*]"> "..." <mut post:Mods> => {
        post.0.insert_str(0, pre);
        post.1.insert(0, 0);
        post.1.iter_mut().for_each(|x| *x = *x + pre.len());
        post
    },
}