use crate::parsing_cocci::smpl_grammar::*;

grammar;

// type SpatchType = (&'input str, Vec<usize>);

pub SPatch: Vec<RuleType<'input>> = {
    Rule => vec![<>],
    <mut s:SPatch> <r:Rule> => {s.push(r); s}
}

Ident = {
    r"[a-zA-Z_][(a-zA-Z0-9_)*]"
}

Rule: RuleType<'input> = {
    "@" <r:RuleName> "@" <h:Header> "@@" <d:Disj> => (r, h, d)
}

RuleName: &'input str = {
    // TODO: Add depends
    Ident
}

Header = {
    "" => vec![],
    MetavarDecls
}

MetavarDecls: Vec<Metavar<'input>> = {
    <t:MetavarType> <def:MetavarDef> ";" => vec![make_metavar(t, def)],
    <decls:MetavarDecls> <mty:MetavarType> <def:MetavarDef> ";" => add_metavar(decls, mty, def)
}

MetavarType = {
    "expression",
    "identifier",
    "parameter"
}

MetavarDef: Vec<&'input str> = {
    Ident => vec![<>],
    <mut defs:MetavarDef> "," <ident:Ident> => { defs.push(ident); defs }
}

DisjBranches: Vec<ModType> {
    <m1: ModType> "|" <m2:ModType> => vec![m1, m2]
    <mut d:DisjBranches> "|" <m:ModType> => {d.push(m); d}
}

Disj: ModType = {
    Mods,
    "(" 
} 

Mods: ModType = {
    r"[a-zA-Z_][(a-zA-Z0-9_)*]" => (<>.to_string(), vec![]),
    <pre:r"[a-zA-Z_][(a-zA-Z0-9_)*]"> "..." <mut post:Mods> => {
        post.0.insert_str(0, pre);
        post.1.insert(0, 0);
        post.1.iter_mut().for_each(|x| *x = *x + pre.len());
        post
    },
}